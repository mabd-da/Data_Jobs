# streamlit run streamlit_final_py_.py
# -*- coding: utf-8 -*-
"""Streamlit_Final.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ukqjzJD3AK1Ck8fzjgWSKa9EP74awG_d

MODIFICATION
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from matplotlib.patches import Patch
import re


df_old = pd.read_csv("kaggle_survey_2020_responses.csv")

df = pd.read_csv('kaggle_survey_2020_group_Q.csv')

# ----------------------------
# 1Ô∏è‚É£ Fonctions globales
# ----------------------------
def afficher_auteurs_sidebar():
    """Fonction pour afficher les auteurs dans la sidebar"""
    st.sidebar.markdown("---")
    st.sidebar.markdown("### üë• Auteurs")
    st.sidebar.markdown("""
    - **Cliford CUPIDON**
    - **Adavan KEOSAVANH**
    - **Olga TIWOA**
    - **M√©lyssa ABDOU**
    """)
    st.sidebar.markdown("*DataScientest - Promotion [mar25_bootcamp_da]*")

# ----------------------------
# Interface Streamlit
# ----------------------------
st.title("Analyse des profils techniques au sein de la data" )
st.sidebar.title("Sommaire")
pages=["Introduction et Contexte", "Pr√©sentation du Dataset", "DataVizualization", "Les profils techniques", "Les t√¢ches et les outils", "Conclusion","Remerciements"]
page=st.sidebar.radio("Aller vers", pages)

# ----------------------------
# 4Ô∏è‚É£ Pages 0 : Intro
# ----------------------------

if page == pages[0] :
    st.title("üè† Introduction")
    st.markdown("""
        Ce projet vise √† analyser les r√©sultats du sondage **Kaggle 2020** pour :
        - üîç Identifier les **profils techniques** les plus repr√©sent√©s
        - üõ†Ô∏è Comprendre les **outils et plateformes** utilis√©s
        - üìÜ Explorer les **activit√©s quotidiennes** des professionnels de la donn√©e
        """)

    st.markdown("""
    <div style='background-color: rgba(255, 75, 75, 0.1);
                padding: 10px;
                border-left: 6px solid #FF4B4B;
                border-radius: 5px;
                margin: 10px 0px'>
    <b>Probl√©matique</b> üß†<br>
    <em>Comment les t√¢ches et outils utilis√©s permettent-ils de mieux comprendre les diff√©rents profils dans l'industrie de la donn√©e ?</em>
    </div>
    """, unsafe_allow_html=True)

    afficher_auteurs_sidebar()

# ----------------------------
# 4Ô∏è‚É£ Pages 1 : Donn√©es
# ----------------------------

if page == pages[1] :
    st.header("Pr√©sentation du Dataset")
    st.write("""
    Le Dataset utilis√© est tir√© du sondage "2020 Kaggle Machine Learning & Data Science Survey"
    r√©alis√© par Kaggle et pr√©sent en acc√®s libre via l‚Äôadresse suivante :
    https://www.kaggle.com/c/kaggle-survey-2020/overview .
    Cette enqu√™te regroupe les r√©ponses de plus de 20 000 professionnels du monde entier.
    Les participants partagent des informations sur leurs r√¥les, les outils et les langages
    qu'ils utilisent, les plateformes sur lesquelles ils travaillent, ainsi que leurs
    formations et pratiques professionnelles
 """)

    st.header("Exploration")
    st.write("""
    Pour explorer et analyser le dataset, nous avons charg√© les donn√©es dans un environnement
    python.

    Voici ci-dessous un extrait du Dataframe avant transformation des donn√©es
""")

    st.subheader("Avant transformation")
    st.dataframe(df_old.head(10))
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Nombre de lignes", df_old.shape[0])
    with col2:
        st.metric("Nombre de colonnes", df_old.shape[1])


    st.header("Nettoyage")
    st.write("""
    Un nettoyage des donn√©es a √©t√© effectu√© pour r√©duire la taille du DataFrame de 355 √† 25
    colonnes :
    - Regroupement des questions √† choix multiples.
    - Traitement des valeurs manquantes en supprimant les colonnes avec plus de 80% de valeurs manquantes.
    - Traitement des doublons.
    - Colonnes renomm√©es avec des noms explicites pour faciliter la lecture et l‚Äôanalyse

    Voici ci-dessous un extrait du Dataframe apr√®s transformation des donn√©es
""")

    st.subheader("Apr√®s transformation (extrait)")
    st.dataframe(df.head(10))

    col1, col2 = st.columns(2)
    with col1:
        st.metric("Nombre de lignes", df.shape[0])
    with col2:
        st.metric("Nombre de colonnes", df.shape[1])

    afficher_auteurs_sidebar()

# ----------------------------
# 4Ô∏è‚É£ Pages 2 : DataViz
# ----------------------------

elif page == pages[2]:
    st.header("DataVizualization")
    st.write("Choisir une visualisation dans la liste ci-dessous pour explorer les donn√©es.")

    viz = st.selectbox("S√©lectionner une visualisation", [
       "R√©partition des r√¥les (pie)",
       "IDE par profils (barplot)",
       "Outils DataViz par profils",
       "Langages par pays (Data Analyst & Data Scientist)",
       "Exp√©rience de codage par genre et profil",
       "Utilisation des ML frameworks par m√©tier"
    ])

    # --- R√©partition des r√¥les (pie)
    if viz == "R√©partition des r√¥les (pie)":
        st.subheader("R√©partition des r√¥les des r√©pondants")
        role_counts = df['job_title'].value_counts().nlargest(9)
        fig, ax = plt.subplots(figsize=(8,8))
        ax.pie(
            role_counts,
            labels=role_counts.index,
            autopct=lambda x: f"{x:.1f}%",
            startangle=90,
            pctdistance=0.8 # rapproche ou √©loigne les %
            )
        ax.axis('equal')
        st.pyplot(fig)

    # --- IDE par profils (barplot)
    elif viz == "IDE par profils (barplot)":
        st.subheader("Environnements de d√©veloppement les plus utilis√©s par profil")

        dfnew = df[["job_title", "IDE"]].copy()
        dfnew['IDE'] = dfnew['IDE'].astype(str).str.replace(r'\(.*?\)', '', regex=True).str.split(',')
        dfnew = dfnew.explode('IDE')
        dfnew['IDE'] = dfnew['IDE'].str.strip()

        #  Filtrer pour garder seulement les m√©tiers pertinents
        top_jobs = ['Data Analyst', 'Machine Learning Engineer', 'Data Scientist', 'Software Engineer', 'Student']
        df_filtered = dfnew[dfnew['job_title'].isin(top_jobs)].copy()

        #  Compter les occurrences
        count_data = df_filtered.groupby(['job_title', 'IDE']).size().reset_index(name='counts')

        # Cr√©ation de la figure
        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            data=count_data,
            y='counts',
            x='job_title',
            hue='IDE',
            palette = "tab20" ,
            edgecolor='black',
            linewidth=1
            )
        plt.title('Environnements de d√©veloppement les plus utilis√©s par profil professionnel(m√©tiers cibl√©s)', y=1.02)
        plt.xlabel('profil professionnel')
        plt.ylabel('Nombre d\'utilisateurs')

        # Rotation + alignement des ticks
        plt.setp(ax.get_xticklabels(), rotation=45, ha='right')

        # L√©gende √† l'ext√©rieur
        ax.legend(
        title="IDE",
        bbox_to_anchor=(1.05, 1),  # position horizontale, verticale
        loc='upper left'  # ancrage

        )
        plt.tight_layout()
        st.pyplot(fig)

    # --- Outils DataViz par profils
    elif viz == "Outils DataViz par profils":
        st.subheader("Outils de DataVisualisation les plus utilis√©s par profils")
        if 'Data_viz_libraries' not in df.columns or 'job_title' not in df.columns:
            st.warning("Colonnes manquantes.")
        else:
            def clean_data_viz(series):
                cleaned = (series.dropna().str.split(',').explode().str.strip().loc[lambda x: x != ''])
                result = cleaned.value_counts().reset_index()
                result.columns = ['Data_viz_libraries', 'count']
                return result

            top_jobs = ['Data Analyst', 'Machine Learning Engineer','Data Scientist','Software Engineer', 'Student']
            fig = plt.figure(figsize=(14, 18))
            i=1
            for job in top_jobs:
                job_series = df[df['job_title'] == job]['Data_viz_libraries'] if 'job_title' in df.columns else pd.Series(dtype='object')
                job_df = clean_data_viz(job_series)
                ax = fig.add_subplot(3,2,i)
                sns.barplot(x='count',
                            y='Data_viz_libraries',
                            data=job_df.head(15),
                            ax=ax,
                            palette='rocket')
                ax.set_title(f'Top outils pour {job}')
                ax.set_xlabel('Nombre d\'utilisateurs')
                ax.set_ylabel('')
                i += 1
            plt.tight_layout()
            st.pyplot(fig)

 # --- Langages par pays (Data Analyst & Data Scientist)
    elif viz == "Langages par pays (Data Analyst & Data Scientist)":
        st.subheader("Langages par pays - Data Analyst & Data Scientist")
        # Nettoyage et pr√©paration
        df_tmp = df[df["programming_languages"].notna()].copy()
        df_tmp["programming_languages"] = df_tmp["programming_languages"].apply(lambda x: [lang.strip() for lang in x.split(",")] if isinstance(x, str) else [])
        df_filtered = df_tmp[df_tmp["job_title"].isin(["Data Analyst", "Data Scientist"])].copy()
        df_exploded = df_filtered.explode("programming_languages").reset_index(drop=True)
        df_exploded = df_exploded[df_exploded["programming_languages"] != ""]

        # Top pays
        top_countries_analyst = df_exploded[df_exploded["job_title"]=="Data Analyst"]["Country_of_residence"].value_counts().nlargest(5).index
        top_countries_scientist = df_exploded[df_exploded["job_title"]=="Data Scientist"]["Country_of_residence"].value_counts().nlargest(5).index
        top_countries = list(set(top_countries_analyst).union(set(top_countries_scientist)))

        df_top = df_exploded[df_exploded["Country_of_residence"].isin(top_countries)].copy()

        # Cr√©er palettes coh√©rentes, pour avoir le m√™me code couleur pour les pays
        unique_countries = sorted(df_top["Country_of_residence"].unique())
        palette_colors = sns.color_palette("Set2", len(unique_countries))
        country_palette = dict(zip(unique_countries, palette_colors))

        # S√©parer les dataframes
        df_analyst = df_top[df_top["job_title"] == "Data Analyst"]
        df_scientist = df_top[df_top["job_title"] == "Data Scientist"]

        top_langs = df_top["programming_languages"].value_counts().index[:10]

        # Plot
        fig, axes = plt.subplots(1, 2, figsize=(22,10), sharey=True)
        sns.countplot(data=df_analyst,
                      x="programming_languages",
                      hue="Country_of_residence",
                      order=top_langs,
                      palette=country_palette,
                      ax=axes[0])
        axes[0].set_title("Langages par pays - Data Analyst", fontsize=30)
        axes[0].set_xlabel("Langages", fontsize=25)
        axes[0].set_ylabel("Nombre de r√©pondants", fontsize=25)
        axes[0].tick_params(axis='x', rotation=45, labelsize=20)
        axes[0].tick_params(axis='y', labelsize=20)

        sns.countplot(data=df_scientist,
                      x="programming_languages",
                      hue="Country_of_residence",
                      order=top_langs,
                      palette=country_palette,
                      ax=axes[1])
        axes[1].set_title("Langages par pays - Data Scientist", fontsize=30)
        axes[1].set_xlabel("Langages", fontsize=25)
        axes[1].set_ylabel("", fontsize=25)
        axes[1].tick_params(axis='x', rotation=45, labelsize=20)
        axes[1].tick_params(axis='y', labelsize=20)

        plt.tight_layout()
        st.pyplot(fig)

    # --- Exp√©rience de codage par genre et profil
    elif viz == "Exp√©rience de codage par genre et profil":
        st.subheader("Exp√©rience de codage selon le genre et le profil technique")
        df_exp = df.dropna(subset=["Coding_experience", "Gender", "job_title"]).copy()

        # Exclure certains profils
        excluded_titles = ["Student", "Other", "Currently not employed"]
        df_exp = df_exp[~df_exp["job_title"].isin(excluded_titles)]

        # Ordre de l‚Äôexp√©rience
        experience_order = [
            "Never written code",
            "< 1 year",
            "1-2 years",
            "3-5 years",
            "5-10 years",
            "10-20 years",
            "20+ years"
            ]

        # Convertir en cat√©gorie ordonn√©e
        df_exp["Coding_experience"] = pd.Categorical(
            df_exp["Coding_experience"],
            categories=experience_order,
            ordered=True)

        # Contexte lisible
        sns.set_context("talk")
        genders = df_exp["Gender"].unique()
        palette = sns.color_palette("Set2", n_colors=len(genders))
        color_map = dict(zip(genders, palette))
        g = sns.catplot(
            data=df_exp,
            x="Coding_experience",
            hue="Gender",
            col="job_title",
            kind="count",
            height=4,
            aspect=1.5,
            palette=color_map,
            col_wrap=2,
            sharey=False,
            legend=False
            )

        #for ax in g.axes.flatten():
            # Rotation + alignement des ticks
            #plt.setp(ax.get_xticklabels(), rotation=45, ha='right')
            #ax.margins(y=0.1)  # ajoute de l‚Äôespace vertical autour des barres
            #ax.set_xlabel("Exp√©rience en code")
            #ax.set_ylabel("Nombre de r√©pondants")

        #---------------------
        for ax in g.axes.flatten():
            # Rotation + alignement des ticks
            plt.setp(ax.get_xticklabels(), rotation=45, ha='right')

            # üî• Rendre les petites barres visibles
            ax.set_yscale("log")

            # ‚ùå Supprimer les ticks sur l‚Äôaxe Y
            ax.tick_params(axis='y', which='both', length=0)

            # Marges et labels
            ax.margins(y=0.1)
            ax.set_xlabel("Exp√©rience en code")
            ax.set_ylabel("Nombre de r√©pondants")

            # üìä Afficher les valeurs au-dessus des barres
            for container in ax.containers:
                ax.bar_label(container, fmt='%.0f', label_type='edge', fontsize=8, padding=2)

        #-------------
        g.fig.subplots_adjust(top=0.88, right=0.82, wspace=0.35, hspace=0.35)



        # Cr√©ation manuelle des patches de l√©gende
        from matplotlib.patches import Patch
        legend_handles = [Patch(color=color_map[gender], label=gender) for gender in genders]


        g.fig.legend(
            handles=legend_handles,
            title="Genre",
            loc='center left',
            bbox_to_anchor=(1.05, 0.5),
            frameon=False
            )

        plt.tight_layout()
        g.fig.subplots_adjust(hspace=0.5)  # plus d‚Äôespace entre les lignes
        st.pyplot(g.fig)

    # --- ML frameworks par m√©tier
    elif viz == "Utilisation des ML frameworks par m√©tier":
        st.subheader("Utilisation des ML Frameworks selon les m√©tiers")
        if 'Ml_frameworks' not in df.columns or 'job_title' not in df.columns:
            st.warning("Colonnes 'Ml_frameworks' ou 'job_title' manquantes.")
        else:
            step1_3_cleaned = df['Ml_frameworks'].dropna().str.split(',').explode().str.strip()
            framework_mapping = {
                'Tensorflow': 'TensorFlow',
                'Pytorch': 'PyTorch',
                'Xgboost': 'XGBoost',
                'Lightgbm': 'LightGBM',
                'Fast.Ai': 'Fastai',
                'Scikit-Learn': 'Scikit-learn',
                'H2O 3': 'H2O.ai'
            }
            step4_standardized = step1_3_cleaned.replace(framework_mapping)
            df_job_framework = pd.concat([
                df.loc[step4_standardized.index, 'job_title'],
                step4_standardized.rename("Framework")
            ], axis=1).dropna()
            top_frameworks = df_job_framework['Framework'].value_counts().head(5).index
            filtered_df = df_job_framework[df_job_framework['Framework'].isin(top_frameworks)]
            fig, ax = plt.subplots(figsize=(12,6))
            sns.countplot(data=filtered_df,
                          x='Framework',
                          hue='job_title',
                          ax=ax,
                          palette="Paired")
            ax.set_title("Utilisation des ML Frameworks par Titre de Poste")
            ax.set_xlabel("Frameworks de Machine Learning")
            ax.set_ylabel("Nombre d'utilisateurs")
            ax.tick_params(axis='x', rotation=45)
            ax.legend(title='Titre de poste', bbox_to_anchor=(1.05, 1), loc='upper left')
            plt.tight_layout()
            st.pyplot(fig)

    afficher_auteurs_sidebar()

# ----------------------------
# 4Ô∏è‚É£ Pages 3 : Profils Techniques
# ----------------------------

if page == pages[3]:
    st.markdown("Explore les r√¥les professionnels, les tranches d'√¢ge, les niveaux d'√©tudes, le genre et les pays des participants √† l'enqu√™te Kaggle 2020.")

    # Filtre pays
    st.sidebar.header("üîé Filtres")
    pays = st.sidebar.multiselect("Filtrer par Pays :", df["Country_of_residence"].dropna().sort_values(ascending=True).unique())

     # Filtre Metier
    metier = st.sidebar.multiselect("Filtrer par M√©tier :", df["job_title"].sort_values(ascending=True).dropna().unique())

     # Application du filtre
    df_filtered = df.copy()

    # Cas 1: Aucun filtre s√©lectionn√© ‚Üí affiche tout
    if not pays and not metier:
        df_filtered = df.copy()

    # Cas 2: Seulement le pays s√©lectionn√© ‚Üí pays + tous les m√©tiers
    elif pays and not metier:
        df_filtered = df_filtered[df_filtered["Country_of_residence"].isin(pays)]

    # Cas 3: Seulement le m√©tier s√©lectionn√© ‚Üí m√©tier + tous les pays
    elif not pays and metier:
        df_filtered = df_filtered[df_filtered["job_title"].isin(metier)]

    # Cas 4: Les deux filtres s√©lectionn√©s ‚Üí pays ET m√©tier
    elif pays and metier:
        df_filtered = df_filtered[
            df_filtered["Country_of_residence"].isin(pays) &
            df_filtered["job_title"].isin(metier)
        ]

    afficher_auteurs_sidebar()

    # Choix analyse
    profil_option = st.radio("Choisir une caract√©ristique √† visualiser :",
                             ["R√¥le professionnel", "Tranche d'√¢ge", "Niveau d'√©tudes", "Genre", "Top 10 des pays"])

    if profil_option == "R√¥le professionnel":
        st.subheader("üíº R√¥le Professionnel")
        counts = df_filtered["job_title"].value_counts().sort_values()
        fig = px.bar(counts, orientation='h',
                     title="R√©partition des r√¥les professionnels",
                     labels={"value": "Nombre", "index": "R√¥le"},
                     color_discrete_sequence=["#1B557E"])
        fig.update_layout(showlegend=False, title_x=0.5)
        fig.update_traces(text=counts.values, textposition='outside')
        st.plotly_chart(fig)

    elif profil_option == "Tranche d'√¢ge":
        st.subheader("üïí Tranche d'√¢ge")
        age_counts = df_filtered["Age"].value_counts().sort_values(ascending=False)
        fig = px.pie(names=age_counts.index, values=age_counts.values,
                     title="R√©partition par tranche d'√¢ge",
                     color_discrete_sequence=px.colors.sequential.RdBu)
        fig.update_layout( title_x=0.5,legend_title_text='√Çge')
        st.plotly_chart(fig)

    elif profil_option == "Niveau d'√©tudes":
        st.subheader("üéì Niveau d'√©tudes")
        counts = df_filtered["Education"].value_counts().sort_values()
        fig = px.bar(counts, orientation='h',
                     title="R√©partition du niveau d'√©tudes",
                     labels={"value": "Nombre", "index": "Niveau"},
                     color_discrete_sequence=["#2ca02c"])
        fig.update_layout(showlegend=False, title_x=0.5)
        fig.update_traces(text=counts.values, textposition='outside')
        st.plotly_chart(fig)

    elif profil_option == "Genre":
        st.subheader("üöª Genre")
        counts = df_filtered["Gender"].value_counts().sort_values()
        fig = px.bar(counts, orientation='h',
                     title="R√©partition par genre",
                     labels={"value": "Nombre", "index": "Genre"},
                     color_discrete_sequence=["#d62728"])
        fig.update_layout(showlegend=False, title_x=0.5)
        fig.update_traces(text=counts.values, textposition='outside')
        st.plotly_chart(fig)

    elif profil_option == "Top 10 des pays":
        st.subheader("üåç Top 10 des pays")
        top_countries = df_filtered["Country_of_residence"].value_counts().nlargest(10).sort_values()
        fig = px.bar(top_countries, orientation='h',
                     title="Top 10 des pays repr√©sent√©s",
                     labels={"value": "Nombre de participants", "index": "Pays"},
                     color_discrete_sequence=["#9467bd"])
        fig.update_layout(showlegend=False, title_x=0.5)
        fig.update_traces(text=top_countries.values, textposition='outside')
        st.plotly_chart(fig)

# ----------------------------
# 4Ô∏è‚É£ Pages 4 : T√¢ches et outils
# ----------------------------
def multiresponse_counts(series, delimiter=","):
    return (series.dropna()
                  .str.split(delimiter)
                  .explode()
                  .str.strip()
                  .value_counts())

if page == pages[4]:
    st.markdown("Visualisez les langages de programmation, biblioth√®ques Python, et plateformes ML les plus utilis√©es par les professionnels de la Data.")

    # Filtre pays
    st.sidebar.header("üîéFiltres")
    pays = st.sidebar.multiselect("Filtrer par pays :", df["Country_of_residence"].dropna().unique())
    df_filtered = df.copy()
    if pays:
        df_filtered = df_filtered[df_filtered["Country_of_residence"].isin(pays)]

    afficher_auteurs_sidebar()

    # S√©lection du profil technique
    roles = df_filtered["job_title"].dropna().unique()
    roles_options = ['All'] + sorted(roles)
    #selected_role = st.selectbox("S√©lectionner un profil technique :", sorted(roles))
    selected_role = st.selectbox("S√©lectionner un profil technique :", roles_options)

    # Si "All" est choisi ‚Üí on garde tout le df_filtered
    if selected_role == "All":
        df_role = df_filtered.copy()
    else:
        df_role = df_filtered[df_filtered["job_title"] == selected_role]

    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs(["Langages", "Outils Dataviz","IDE" ,"Outils/Plateformes ML", "Les t√¢ches effectu√©es", "Exp√©rience en programmation"])

    with tab1:
        st.subheader("üíª Langages de programmation")
        lang_counts = multiresponse_counts(df_role["programming_languages"])
        fig = px.bar(lang_counts, orientation='h',
                     title="Langages les plus populaires",
                     labels={'value': 'Nombre', 'index': 'Langage'},
                     color='value',
                     color_continuous_scale='Plasma')
        fig.update_layout(showlegend=False, title_x=0.5)
        st.plotly_chart(fig)

    with tab2:
        st.subheader("üìö Outils Dataviz")
        lib_counts = multiresponse_counts(df_role["Data_viz_libraries"])
        fig = px.bar(lib_counts, orientation='h',
                     title="Outils Python les plus utilis√©s",
                     labels={'value': 'Nombre', 'index': 'Biblioth√®que'},
                     color='value',
                     color_continuous_scale='Plasma')
        fig.update_layout(showlegend=False, title_x=0.5)
        st.plotly_chart(fig)

    with tab3:

        st.subheader("üõ†Ô∏è IDE les plus utilis√©s")

        # 1) S√©rie propre
        s = df_role["IDE"].dropna().astype(str)
        s = s.str.replace(r',?\s*etc\.?\)?', '', regex=True, flags=re.IGNORECASE)\
            .str.replace(r'\(\s*\)', '', regex=True)\
            .str.replace(r'[;|/]+', ',', regex=True)\
            .str.replace(r'\s{2,}', ' ', regex=True).str.strip()

        # 2) Exploser les r√©ponses multiples
        items = s.str.split(',').explode().str.strip()
        items = items[items.notna() & items.ne('')]

        # 3) Normaliser quelques libell√©s
        items = items.str.replace(r'(?i)^jupyter.*$', 'Jupyter', regex=True)
        items = items.str.replace(r'(?i)^visual studio code.*$', 'VS Code', regex=True)
        items = items.str.replace(r'(?i)^r\s*studio$', 'RStudio', regex=True)
        items = items[~items.str.match(r'(?i)^(etc|nan)$')]

        # 4) Comptes
        counts = items.value_counts()  # Series index=IDE, values=Nombre

        # 5) ORDONNANCE : petit -> grand (pour que le plus grand soit EN BAS)
        ordered_idx = counts.sort_values(ascending=True).index.tolist()

        # 6) DataFrame + CATEGORIE ORDONN√âE (cl√© pour forcer l'ordre)
        df_plot = counts.reset_index()
        df_plot.columns = ["IDE", "Nombre"]
        df_plot["IDE"] = pd.Categorical(df_plot["IDE"], categories=ordered_idx, ordered=True)
        df_plot = df_plot.sort_values("IDE")  # suit l'ordre cat√©goriel d√©fini

        # 7) Graphique (valeurs uniquement)
        fig = px.bar(
            df_plot,
            x="Nombre", y="IDE",
            orientation="h",
            title="IDE les plus populaires",
            labels={"Nombre": "Nombre", "IDE": "IDE"},
            color="Nombre",
            color_continuous_scale="Plasma",

            # on redonne l'ordre au cas o√π
            category_orders={"IDE": ordered_idx}
        )
        fig.update_traces(textposition="outside", cliponaxis=False)
        st.plotly_chart(fig, use_container_width=True)




    with tab4:
        st.subheader("üì¶ Outils / plateformes de Machine Learning")
        ml_counts = multiresponse_counts(df_role["Ml_frameworks"])
        fig = px.bar(ml_counts, orientation='h',
                     title="Outils / Plateformes de ML",
                     labels={'value': 'Nombre', 'index': 'Outil'},
                     color='value',
                     color_continuous_scale='Plasma')
        fig.update_layout(showlegend=False, title_x=0.5)
        st.plotly_chart(fig)


    ROLE_OPTIONS = [
        "Analyze and understand data to influence product or business decisions",
        "Build and/or run the data infrastructure that my business uses for storing, analyzing, and operationalizing data",
        "Build prototypes to explore applying machine learning to new areas",
        "Build and/or run a machine learning service that operationally improves my product or workflows",
        "Experimentation and iteration to improve existing ML models",
        "Do research that advances the state of the art of machine learning",
        "None of these activities are an important part of my role at work",
        "Other"
    ]

    def role_counts(series):
        counts = {}
        for response in series.dropna():
            for option in ROLE_OPTIONS:
                if option in response:
                    counts[option] = counts.get(option, 0) + 1
        return pd.Series(counts).sort_values(ascending=False)

    with tab5:
        st.subheader("üìà T√¢ches effectu√©es")
        task_counts = role_counts(df_role["Role/Activities"])
        fig = px.bar(task_counts, orientation='h',
                 title="R√©partition des t√¢ches effectu√©es",
                 labels={'value': 'Nombre', 'index': 'T√¢che'},
                 color='value',
                 color_continuous_scale='Plasma')
        fig.update_layout(showlegend=False, title_x=0.5)
        st.plotly_chart(fig)

    with tab6:
        st.subheader("üë©‚ÄçüíªExp√©rience en programmation")

        # Comptage par Age et Exp√©rience
        xp_counts = df_role.groupby(["Age", "Coding_experience"]).size().reset_index(name="count")

        # Graphique avec palette Plasma (d√©j√† int√©gr√©e)
        fig = px.bar(
            xp_counts,
            x="count",
            y="Age",
            color="Coding_experience",
            orientation="h",
            title="Exp√©rience en programmation par √¢ge",
            labels={'count': 'Nombre', 'Coding_experience': 'Exp√©rience'},
            color_discrete_sequence=px.colors.sequential.Plasma  # palette pr√™te
        )

        fig.update_layout(
            barmode="stack",   # barres empil√©es
            title_x=0.5
        )

        st.plotly_chart(fig)
# ----------------------------
# 4Ô∏è‚É£ Pages 5 : Conclusion
# ----------------------------
if page == pages[5] :
    st.title("‚úÖ Conclusion")
    ("""
    Cette √©tude, bas√©e sur les r√©ponses au sondage Kaggle 2020, met en √©vidence la grande diversit√© des profils
    au sein de l'industrie de la Data.

    **Principaux renseignements :**
    - Plusieurs m√©tiers coexistent : Data Scientist, Data Analyst, Machine Learning Engineer, etc.
    - Python domine largement les langages utilis√©s, souvent associ√© √† Jupyter et Colab.
    - Les outils et plateformes varient fortement selon le niveau d‚Äôexp√©rience.

    **Perspectives :**
    - Etendre l'√©tude √† d'autres ann√©es.
    - Exp√©rimenter diff√©rents algorithmes de clustering.
    - Mettre en place un mod√®le pr√©dictif.
    - Croiser ces r√©sultats avec les donn√©es du march√© de l'emploi.

    """)
    afficher_auteurs_sidebar()

# ----------------------------
# 4Ô∏è‚É£ Pages 6 : Remerciements
# ----------------------------
if page == pages[6] :
    st.title("üôè Merci pour votre attention et d‚Äôavoir explor√© avec nous üöÄ")
    st.markdown(
    "<h2 style='text-align: center;'>üéØPlace aux questions ! üéØ</h2>",
    unsafe_allow_html=True)

    afficher_auteurs_sidebar()